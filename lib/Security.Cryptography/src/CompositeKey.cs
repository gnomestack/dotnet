using System.Collections;
using System.Diagnostics.CodeAnalysis;
using System.Security.Cryptography;

namespace GnomeStack.Security.Cryptography
{
    /// <summary>
    /// A key that is made up of composite fragments that generates a single span of
    /// bytes to use as a key. The order in which a fragment is added influences output
    /// of generated bytes.
    /// </summary>
    [SuppressMessage(
        "Microsoft.Naming",
        "CA1710: Identifiers should have correct suffix",
        Justification = "By Design")]
    public class CompositeKey : ICompositeKey
    {
        private readonly List<ICompositeKeyFragment> fragments = new List<ICompositeKeyFragment>();

        public CompositeKey()
        {
            this.HashAlgorithm = HashAlgorithmName.SHA256;
        }

        public CompositeKey(HashAlgorithmName name)
        {
            this.HashAlgorithm = name;
        }

        public HashAlgorithmName HashAlgorithm { get; }

        public int Count => this.fragments.Count;

        protected IList<ICompositeKeyFragment> Fragments => this.fragments;

        public void Add(ICompositeKeyFragment fragment)
            => this.fragments.Add(fragment);

        public virtual ReadOnlySpan<byte> AssembleKey()
        {
            using (var ms = new MemoryStream())
            {
                foreach (var fragment in this.fragments)
                {
                    var span = fragment.ToReadOnlySpan();
                    ms.Write(span);
                }

                using (var hmac = this.CreateHmac())
                {
                    return hmac.ComputeHash(ms.ToArray());
                }
            }
        }

        public void Clear()
            => this.fragments.Clear();

        public void Dispose()
        {
            this.Dispose(true);
            GC.SuppressFinalize(this);
        }

        public IEnumerator<ICompositeKeyFragment> GetEnumerator()
            => this.fragments.GetEnumerator();

        public void Remove(ICompositeKeyFragment fragment)
            => this.fragments.Remove(fragment);

        IEnumerator IEnumerable.GetEnumerator()
            => this.GetEnumerator();

        protected virtual void Dispose(bool disposing)
        {
            if (disposing)
            {
                foreach (var fragment in this.fragments)
                    fragment.Dispose();

                this.fragments.Clear();
            }
        }

        private HMAC CreateHmac()
        {
            HashAlgorithmName hashAlgorithm = this.HashAlgorithm;

            if (string.IsNullOrEmpty(hashAlgorithm.Name))
                throw new CryptographicException("HashAlgorithm is null or empty");

            if (hashAlgorithm == HashAlgorithmName.SHA256)
                return new HMACSHA256();
            if (hashAlgorithm == HashAlgorithmName.SHA384)
                return new HMACSHA384();
            if (hashAlgorithm == HashAlgorithmName.SHA512)
                return new HMACSHA512();

            throw new CryptographicException($"Algorithm {hashAlgorithm.Name} not supported");
        }
    }
}