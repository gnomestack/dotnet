using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Globalization;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.RegularExpressions;

using Dapper;

using Polly;

namespace GnomeStack.Data;

public static class DapperRetryExtensions
{
    /// <summary>
    /// Execute parameterized SQL.
    /// </summary>
    /// <param name="cnn">The connection to query on.</param>
    /// <param name="sql">The SQL to execute for this query.</param>
    /// <param name="param">The parameters to use for this query.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>The number of rows affected.</returns>
    public static int Execute(this IDbConnection cnn, string sql, object param = null,
        IDbTransaction transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        var command =
            new CommandDefinition(sql, param, transaction, commandTimeout, commandType, CommandFlags.Buffered);
        return ExecuteImpl(cnn, ref command);
    }

    /// <summary>
    /// Execute parameterized SQL.
    /// </summary>
    /// <param name="cnn">The connection to execute on.</param>
    /// <param name="command">The command to execute on this connection.</param>
    /// <returns>The number of rows affected.</returns>
    public static int Execute(this IDbConnection cnn, CommandDefinition command) => ExecuteImpl(cnn, ref command);

    /// <summary>
    /// Execute parameterized SQL that selects a single value.
    /// </summary>
    /// <param name="cnn">The connection to execute on.</param>
    /// <param name="sql">The SQL to execute.</param>
    /// <param name="param">The parameters to use for this command.</param>
    /// <param name="transaction">The transaction to use for this command.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>The first cell selected as <see cref="object"/>.</returns>
    public static object ExecuteScalar(this IDbConnection cnn, string sql, object param = null,
        IDbTransaction transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        var command =
            new CommandDefinition(sql, param, transaction, commandTimeout, commandType, CommandFlags.Buffered);
        return ExecuteScalarImpl<object>(cnn, ref command);
    }

    /// <summary>
    /// Execute parameterized SQL that selects a single value.
    /// </summary>
    /// <typeparam name="T">The type to return.</typeparam>
    /// <param name="cnn">The connection to execute on.</param>
    /// <param name="sql">The SQL to execute.</param>
    /// <param name="param">The parameters to use for this command.</param>
    /// <param name="transaction">The transaction to use for this command.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>The first cell returned, as <typeparamref name="T"/>.</returns>
    public static T ExecuteScalar<T>(this IDbConnection cnn, string sql, object param = null,
        IDbTransaction transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        var command =
            new CommandDefinition(sql, param, transaction, commandTimeout, commandType, CommandFlags.Buffered);
        return ExecuteScalarImpl<T>(cnn, ref command);
    }

    /// <summary>
    /// Execute parameterized SQL that selects a single value.
    /// </summary>
    /// <param name="cnn">The connection to execute on.</param>
    /// <param name="command">The command to execute.</param>
    /// <returns>The first cell selected as <see cref="object"/>.</returns>
    public static object ExecuteScalar(this IDbConnection cnn, CommandDefinition command) =>
        ExecuteScalarImpl<object>(cnn, ref command);

    /// <summary>
    /// Execute parameterized SQL that selects a single value.
    /// </summary>
    /// <typeparam name="T">The type to return.</typeparam>
    /// <param name="cnn">The connection to execute on.</param>
    /// <param name="command">The command to execute.</param>
    /// <returns>The first cell selected as <typeparamref name="T"/>.</returns>
    public static T ExecuteScalar<T>(this IDbConnection cnn, CommandDefinition command) =>
        ExecuteScalarImpl<T>(cnn, ref command);
    


    /// <summary>
    /// Execute parameterized SQL and return an <see cref="IDataReader"/>.
    /// </summary>
    /// <param name="cnn">The connection to execute on.</param>
    /// <param name="sql">The SQL to execute.</param>
    /// <param name="param">The parameters to use for this command.</param>
    /// <param name="transaction">The transaction to use for this command.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>An <see cref="IDataReader"/> that can be used to iterate over the results of the SQL query.</returns>
    /// <remarks>
    /// This is typically used when the results of a query are not processed by Dapper, for example, used to fill a <see cref="DataTable"/>
    /// or <see cref="T:DataSet"/>.
    /// </remarks>
    /// <example>
    /// <code>
    /// <![CDATA[
    /// DataTable table = new DataTable("MyTable");
    /// using (var reader = ExecuteReader(cnn, sql, param))
    /// {
    ///     table.Load(reader);
    /// }
    /// ]]>
    /// </code>
    /// </example>
    public static IDataReader ExecuteReader(this IDbConnection cnn, string sql, object param = null,
        IDbTransaction transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        var command =
            new CommandDefinition(sql, param, transaction, commandTimeout, commandType, CommandFlags.Buffered);
        var reader = ExecuteReaderImpl(cnn, ref command, CommandBehavior.Default, out IDbCommand dbcmd);
        return WrappedReader.Create(dbcmd, reader);
    }

    /// <summary>
    /// Execute parameterized SQL and return an <see cref="IDataReader"/>.
    /// </summary>
    /// <param name="cnn">The connection to execute on.</param>
    /// <param name="command">The command to execute.</param>
    /// <returns>An <see cref="IDataReader"/> that can be used to iterate over the results of the SQL query.</returns>
    /// <remarks>
    /// This is typically used when the results of a query are not processed by Dapper, for example, used to fill a <see cref="DataTable"/>
    /// or <see cref="T:DataSet"/>.
    /// </remarks>
    public static IDataReader ExecuteReader(this IDbConnection cnn, CommandDefinition command)
    {
        var reader = ExecuteReaderImpl(cnn, ref command, CommandBehavior.Default, out IDbCommand dbcmd);
        return WrappedReader.Create(dbcmd, reader);
    }

    /// <summary>
    /// Execute parameterized SQL and return an <see cref="IDataReader"/>.
    /// </summary>
    /// <param name="cnn">The connection to execute on.</param>
    /// <param name="command">The command to execute.</param>
    /// <param name="commandBehavior">The <see cref="CommandBehavior"/> flags for this reader.</param>
    /// <returns>An <see cref="IDataReader"/> that can be used to iterate over the results of the SQL query.</returns>
    /// <remarks>
    /// This is typically used when the results of a query are not processed by Dapper, for example, used to fill a <see cref="DataTable"/>
    /// or <see cref="T:DataSet"/>.
    /// </remarks>
    public static IDataReader ExecuteReader(this IDbConnection cnn, CommandDefinition command,
        CommandBehavior commandBehavior)
    {
        var reader = ExecuteReaderImpl(cnn, ref command, commandBehavior, out IDbCommand dbcmd);
        return WrappedReader.Create(dbcmd, reader);
    }

    /// <summary>
    /// Return a sequence of dynamic objects with properties matching the columns.
    /// </summary>
    /// <param name="cnn">The connection to query on.</param>
    /// <param name="sql">The SQL to execute for the query.</param>
    /// <param name="param">The parameters to pass, if any.</param>
    /// <param name="transaction">The transaction to use, if any.</param>
    /// <param name="buffered">Whether to buffer the results in memory.</param>
    /// <param name="commandTimeout">The command timeout (in seconds).</param>
    /// <param name="commandType">The type of command to execute.</param>
    /// <remarks>Note: each row can be accessed via "dynamic", or by casting to an IDictionary&lt;string,object&gt;</remarks>
    public static IEnumerable<dynamic> Query(this IDbConnection cnn, string sql, object param = null,
        IDbTransaction transaction = null, bool buffered = true, int? commandTimeout = null,
        CommandType? commandType = null) =>
        Query<DapperRow>(cnn, sql, param, transaction, buffered, commandTimeout, commandType);

    /// <summary>
    /// Return a dynamic object with properties matching the columns.
    /// </summary>
    /// <param name="cnn">The connection to query on.</param>
    /// <param name="sql">The SQL to execute for the query.</param>
    /// <param name="param">The parameters to pass, if any.</param>
    /// <param name="transaction">The transaction to use, if any.</param>
    /// <param name="commandTimeout">The command timeout (in seconds).</param>
    /// <param name="commandType">The type of command to execute.</param>
    /// <remarks>Note: the row can be accessed via "dynamic", or by casting to an IDictionary&lt;string,object&gt;</remarks>
    public static dynamic QueryFirst(this IDbConnection cnn, string sql, object param = null,
        IDbTransaction transaction = null, int? commandTimeout = null, CommandType? commandType = null) =>
        QueryFirst<DapperRow>(cnn, sql, param, transaction, commandTimeout, commandType);

    /// <summary>
    /// Return a dynamic object with properties matching the columns.
    /// </summary>
    /// <param name="cnn">The connection to query on.</param>
    /// <param name="sql">The SQL to execute for the query.</param>
    /// <param name="param">The parameters to pass, if any.</param>
    /// <param name="transaction">The transaction to use, if any.</param>
    /// <param name="commandTimeout">The command timeout (in seconds).</param>
    /// <param name="commandType">The type of command to execute.</param>
    /// <remarks>Note: the row can be accessed via "dynamic", or by casting to an IDictionary&lt;string,object&gt;</remarks>
    public static dynamic QueryFirstOrDefault(this IDbConnection cnn, string sql, object param = null,
        IDbTransaction transaction = null, int? commandTimeout = null, CommandType? commandType = null) =>
        QueryFirstOrDefault<DapperRow>(cnn, sql, param, transaction, commandTimeout, commandType);

    /// <summary>
    /// Return a dynamic object with properties matching the columns.
    /// </summary>
    /// <param name="cnn">The connection to query on.</param>
    /// <param name="sql">The SQL to execute for the query.</param>
    /// <param name="param">The parameters to pass, if any.</param>
    /// <param name="transaction">The transaction to use, if any.</param>
    /// <param name="commandTimeout">The command timeout (in seconds).</param>
    /// <param name="commandType">The type of command to execute.</param>
    /// <remarks>Note: the row can be accessed via "dynamic", or by casting to an IDictionary&lt;string,object&gt;</remarks>
    public static dynamic QuerySingle(this IDbConnection cnn, string sql, object param = null,
        IDbTransaction transaction = null, int? commandTimeout = null, CommandType? commandType = null) =>
        QuerySingle<DapperRow>(cnn, sql, param, transaction, commandTimeout, commandType);

    /// <summary>
    /// Return a dynamic object with properties matching the columns.
    /// </summary>
    /// <param name="cnn">The connection to query on.</param>
    /// <param name="sql">The SQL to execute for the query.</param>
    /// <param name="param">The parameters to pass, if any.</param>
    /// <param name="transaction">The transaction to use, if any.</param>
    /// <param name="commandTimeout">The command timeout (in seconds).</param>
    /// <param name="commandType">The type of command to execute.</param>
    /// <remarks>Note: the row can be accessed via "dynamic", or by casting to an IDictionary&lt;string,object&gt;</remarks>
    public static dynamic QuerySingleOrDefault(this IDbConnection cnn, string sql, object param = null,
        IDbTransaction transaction = null, int? commandTimeout = null, CommandType? commandType = null) =>
        QuerySingleOrDefault<DapperRow>(cnn, sql, param, transaction, commandTimeout, commandType);

    /// <summary>
    /// Executes a query, returning the data typed as <typeparamref name="T"/>.
    /// </summary>
    /// <typeparam name="T">The type of results to return.</typeparam>
    /// <param name="cnn">The connection to query on.</param>
    /// <param name="sql">The SQL to execute for the query.</param>
    /// <param name="param">The parameters to pass, if any.</param>
    /// <param name="transaction">The transaction to use, if any.</param>
    /// <param name="buffered">Whether to buffer results in memory.</param>
    /// <param name="commandTimeout">The command timeout (in seconds).</param>
    /// <param name="commandType">The type of command to execute.</param>
    /// <returns>
    /// A sequence of data of the supplied type; if a basic type (int, string, etc) is queried then the data from the first column is assumed, otherwise an instance is
    /// created per row, and a direct column-name===member-name mapping is assumed (case insensitive).
    /// </returns>
    public static IEnumerable<T> Query<T>(this IDbConnection cnn, string sql, object param = null,
        IDbTransaction transaction = null, bool buffered = true, int? commandTimeout = null,
        CommandType? commandType = null)
    {
        var command = new CommandDefinition(sql, param, transaction, commandTimeout, commandType,
            buffered ? CommandFlags.Buffered : CommandFlags.None);
        var data = QueryImpl<T>(cnn, command, typeof(T));
        return command.Buffered ? data.ToList() : data;
    }

    /// <summary>
    /// Executes a single-row query, returning the data typed as <typeparamref name="T"/>.
    /// </summary>
    /// <typeparam name="T">The type of result to return.</typeparam>
    /// <param name="cnn">The connection to query on.</param>
    /// <param name="sql">The SQL to execute for the query.</param>
    /// <param name="param">The parameters to pass, if any.</param>
    /// <param name="transaction">The transaction to use, if any.</param>
    /// <param name="commandTimeout">The command timeout (in seconds).</param>
    /// <param name="commandType">The type of command to execute.</param>
    /// <returns>
    /// A sequence of data of the supplied type; if a basic type (int, string, etc) is queried then the data from the first column is assumed, otherwise an instance is
    /// created per row, and a direct column-name===member-name mapping is assumed (case insensitive).
    /// </returns>
    public static T QueryFirst<T>(this IDbConnection cnn, string sql, object param = null,
        IDbTransaction transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        var command = new CommandDefinition(sql, param, transaction, commandTimeout, commandType, CommandFlags.None);
        return QueryRowImpl<T>(cnn, Row.First, ref command, typeof(T));
    }

    /// <summary>
    /// Executes a single-row query, returning the data typed as <typeparamref name="T"/>.
    /// </summary>
    /// <typeparam name="T">The type of result to return.</typeparam>
    /// <param name="cnn">The connection to query on.</param>
    /// <param name="sql">The SQL to execute for the query.</param>
    /// <param name="param">The parameters to pass, if any.</param>
    /// <param name="transaction">The transaction to use, if any.</param>
    /// <param name="commandTimeout">The command timeout (in seconds).</param>
    /// <param name="commandType">The type of command to execute.</param>
    /// <returns>
    /// A sequence of data of the supplied type; if a basic type (int, string, etc) is queried then the data from the first column is assumed, otherwise an instance is
    /// created per row, and a direct column-name===member-name mapping is assumed (case insensitive).
    /// </returns>
    public static T QueryFirstOrDefault<T>(this IDbConnection cnn, string sql, object param = null,
        IDbTransaction transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        var command = new CommandDefinition(sql, param, transaction, commandTimeout, commandType, CommandFlags.None);
        return QueryRowImpl<T>(cnn, Row.FirstOrDefault, ref command, typeof(T));
    }

    /// <summary>
    /// Executes a single-row query, returning the data typed as <typeparamref name="T"/>.
    /// </summary>
    /// <typeparam name="T">The type of result to return.</typeparam>
    /// <param name="cnn">The connection to query on.</param>
    /// <param name="sql">The SQL to execute for the query.</param>
    /// <param name="param">The parameters to pass, if any.</param>
    /// <param name="transaction">The transaction to use, if any.</param>
    /// <param name="commandTimeout">The command timeout (in seconds).</param>
    /// <param name="commandType">The type of command to execute.</param>
    /// <returns>
    /// A sequence of data of the supplied type; if a basic type (int, string, etc) is queried then the data from the first column is assumed, otherwise an instance is
    /// created per row, and a direct column-name===member-name mapping is assumed (case insensitive).
    /// </returns>
    public static T QuerySingle<T>(this IDbConnection cnn, string sql, object param = null,
        IDbTransaction transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        var command = new CommandDefinition(sql, param, transaction, commandTimeout, commandType, CommandFlags.None);
        return QueryRowImpl<T>(cnn, Row.Single, ref command, typeof(T));
    }

    /// <summary>
    /// Executes a single-row query, returning the data typed as <typeparamref name="T"/>.
    /// </summary>
    /// <typeparam name="T">The type of result to return.</typeparam>
    /// <param name="cnn">The connection to query on.</param>
    /// <param name="sql">The SQL to execute for the query.</param>
    /// <param name="param">The parameters to pass, if any.</param>
    /// <param name="transaction">The transaction to use, if any.</param>
    /// <param name="commandTimeout">The command timeout (in seconds).</param>
    /// <param name="commandType">The type of command to execute.</param>
    /// <returns>
    /// A sequence of data of the supplied type; if a basic type (int, string, etc) is queried then the data from the first column is assumed, otherwise an instance is
    /// created per row, and a direct column-name===member-name mapping is assumed (case insensitive).
    /// </returns>
    public static T QuerySingleOrDefault<T>(this IDbConnection cnn, string sql, object param = null,
        IDbTransaction transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        var command = new CommandDefinition(sql, param, transaction, commandTimeout, commandType, CommandFlags.None);
        return QueryRowImpl<T>(cnn, Row.SingleOrDefault, ref command, typeof(T));
    }

    /// <summary>
    /// Executes a single-row query, returning the data typed as <paramref name="type"/>.
    /// </summary>
    /// <param name="cnn">The connection to query on.</param>
    /// <param name="type">The type to return.</param>
    /// <param name="sql">The SQL to execute for the query.</param>
    /// <param name="param">The parameters to pass, if any.</param>
    /// <param name="transaction">The transaction to use, if any.</param>
    /// <param name="buffered">Whether to buffer results in memory.</param>
    /// <param name="commandTimeout">The command timeout (in seconds).</param>
    /// <param name="commandType">The type of command to execute.</param>
    /// <exception cref="ArgumentNullException"><paramref name="type"/> is <c>null</c>.</exception>
    /// <returns>
    /// A sequence of data of the supplied type; if a basic type (int, string, etc) is queried then the data from the first column is assumed, otherwise an instance is
    /// created per row, and a direct column-name===member-name mapping is assumed (case insensitive).
    /// </returns>
    public static IEnumerable<object> Query(this IDbConnection cnn, Type type, string sql, object param = null,
        IDbTransaction transaction = null, bool buffered = true, int? commandTimeout = null,
        CommandType? commandType = null)
    {
        if (type == null) throw new ArgumentNullException(nameof(type));
        var command = new CommandDefinition(sql, param, transaction, commandTimeout, commandType,
            buffered ? CommandFlags.Buffered : CommandFlags.None);
        var data = QueryImpl<object>(cnn, command, type);
        return command.Buffered ? data.ToList() : data;
    }

    /// <summary>
    /// Executes a single-row query, returning the data typed as <paramref name="type"/>.
    /// </summary>
    /// <param name="cnn">The connection to query on.</param>
    /// <param name="type">The type to return.</param>
    /// <param name="sql">The SQL to execute for the query.</param>
    /// <param name="param">The parameters to pass, if any.</param>
    /// <param name="transaction">The transaction to use, if any.</param>
    /// <param name="commandTimeout">The command timeout (in seconds).</param>
    /// <param name="commandType">The type of command to execute.</param>
    /// <exception cref="ArgumentNullException"><paramref name="type"/> is <c>null</c>.</exception>
    /// <returns>
    /// A sequence of data of the supplied type; if a basic type (int, string, etc) is queried then the data from the first column is assumed, otherwise an instance is
    /// created per row, and a direct column-name===member-name mapping is assumed (case insensitive).
    /// </returns>
    public static object QueryFirst(this IDbConnection cnn, Type type, string sql, object param = null,
        IDbTransaction transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        if (type == null) throw new ArgumentNullException(nameof(type));
        var command = new CommandDefinition(sql, param, transaction, commandTimeout, commandType, CommandFlags.None);
        return QueryRowImpl<object>(cnn, Row.First, ref command, type);
    }

    /// <summary>
    /// Executes a single-row query, returning the data typed as <paramref name="type"/>.
    /// </summary>
    /// <param name="cnn">The connection to query on.</param>
    /// <param name="type">The type to return.</param>
    /// <param name="sql">The SQL to execute for the query.</param>
    /// <param name="param">The parameters to pass, if any.</param>
    /// <param name="transaction">The transaction to use, if any.</param>
    /// <param name="commandTimeout">The command timeout (in seconds).</param>
    /// <param name="commandType">The type of command to execute.</param>
    /// <exception cref="ArgumentNullException"><paramref name="type"/> is <c>null</c>.</exception>
    /// <returns>
    /// A sequence of data of the supplied type; if a basic type (int, string, etc) is queried then the data from the first column is assumed, otherwise an instance is
    /// created per row, and a direct column-name===member-name mapping is assumed (case insensitive).
    /// </returns>
    public static object QueryFirstOrDefault(this IDbConnection cnn, Type type, string sql, object param = null,
        IDbTransaction transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        if (type == null) throw new ArgumentNullException(nameof(type));
        var command = new CommandDefinition(sql, param, transaction, commandTimeout, commandType, CommandFlags.None);
        return QueryRowImpl<object>(cnn, Row.FirstOrDefault, ref command, type);
    }

    /// <summary>
    /// Executes a single-row query, returning the data typed as <paramref name="type"/>.
    /// </summary>
    /// <param name="cnn">The connection to query on.</param>
    /// <param name="type">The type to return.</param>
    /// <param name="sql">The SQL to execute for the query.</param>
    /// <param name="param">The parameters to pass, if any.</param>
    /// <param name="transaction">The transaction to use, if any.</param>
    /// <param name="commandTimeout">The command timeout (in seconds).</param>
    /// <param name="commandType">The type of command to execute.</param>
    /// <exception cref="ArgumentNullException"><paramref name="type"/> is <c>null</c>.</exception>
    /// <returns>
    /// A sequence of data of the supplied type; if a basic type (int, string, etc) is queried then the data from the first column is assumed, otherwise an instance is
    /// created per row, and a direct column-name===member-name mapping is assumed (case insensitive).
    /// </returns>
    public static object QuerySingle(this IDbConnection cnn, Type type, string sql, object param = null,
        IDbTransaction transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        if (type == null) throw new ArgumentNullException(nameof(type));
        var command = new CommandDefinition(sql, param, transaction, commandTimeout, commandType, CommandFlags.None);
        return QueryRowImpl<object>(cnn, Row.Single, ref command, type);
    }

    /// <summary>
    /// Executes a single-row query, returning the data typed as <paramref name="type"/>.
    /// </summary>
    /// <param name="cnn">The connection to query on.</param>
    /// <param name="type">The type to return.</param>
    /// <param name="sql">The SQL to execute for the query.</param>
    /// <param name="param">The parameters to pass, if any.</param>
    /// <param name="transaction">The transaction to use, if any.</param>
    /// <param name="commandTimeout">The command timeout (in seconds).</param>
    /// <param name="commandType">The type of command to execute.</param>
    /// <exception cref="ArgumentNullException"><paramref name="type"/> is <c>null</c>.</exception>
    /// <returns>
    /// A sequence of data of the supplied type; if a basic type (int, string, etc) is queried then the data from the first column is assumed, otherwise an instance is
    /// created per row, and a direct column-name===member-name mapping is assumed (case insensitive).
    /// </returns>
    public static object QuerySingleOrDefault(this IDbConnection cnn, Type type, string sql, object param = null,
        IDbTransaction transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        if (type == null) throw new ArgumentNullException(nameof(type));
        var command = new CommandDefinition(sql, param, transaction, commandTimeout, commandType, CommandFlags.None);
        return QueryRowImpl<object>(cnn, Row.SingleOrDefault, ref command, type);
    }

    /// <summary>
    /// Executes a query, returning the data typed as <typeparamref name="T"/>.
    /// </summary>
    /// <typeparam name="T">The type of results to return.</typeparam>
    /// <param name="cnn">The connection to query on.</param>
    /// <param name="command">The command used to query on this connection.</param>
    /// <returns>
    /// A sequence of data of <typeparamref name="T"/>; if a basic type (int, string, etc) is queried then the data from the first column is assumed, otherwise an instance is
    /// created per row, and a direct column-name===member-name mapping is assumed (case insensitive).
    /// </returns>
    public static IEnumerable<T> Query<T>(this IDbConnection cnn, CommandDefinition command)
    {
        var data = QueryImpl<T>(cnn, command, typeof(T));
        return command.Buffered ? data.ToList() : data;
    }

    /// <summary>
    /// Executes a query, returning the data typed as <typeparamref name="T"/>.
    /// </summary>
    /// <typeparam name="T">The type of results to return.</typeparam>
    /// <param name="cnn">The connection to query on.</param>
    /// <param name="command">The command used to query on this connection.</param>
    /// <returns>
    /// A single instance or null of the supplied type; if a basic type (int, string, etc) is queried then the data from the first column is assumed, otherwise an instance is
    /// created per row, and a direct column-name===member-name mapping is assumed (case insensitive).
    /// </returns>
    public static T QueryFirst<T>(this IDbConnection cnn, CommandDefinition command) =>
        QueryRowImpl<T>(cnn, Row.First, ref command, typeof(T));

    /// <summary>
    /// Executes a query, returning the data typed as <typeparamref name="T"/>.
    /// </summary>
    /// <typeparam name="T">The type of results to return.</typeparam>
    /// <param name="cnn">The connection to query on.</param>
    /// <param name="command">The command used to query on this connection.</param>
    /// <returns>
    /// A single or null instance of the supplied type; if a basic type (int, string, etc) is queried then the data from the first column is assumed, otherwise an instance is
    /// created per row, and a direct column-name===member-name mapping is assumed (case insensitive).
    /// </returns>
    public static T QueryFirstOrDefault<T>(this IDbConnection cnn, CommandDefinition command) =>
        QueryRowImpl<T>(cnn, Row.FirstOrDefault, ref command, typeof(T));

    /// <summary>
    /// Executes a query, returning the data typed as <typeparamref name="T"/>.
    /// </summary>
    /// <typeparam name="T">The type of results to return.</typeparam>
    /// <param name="cnn">The connection to query on.</param>
    /// <param name="command">The command used to query on this connection.</param>
    /// <returns>
    /// A single instance of the supplied type; if a basic type (int, string, etc) is queried then the data from the first column is assumed, otherwise an instance is
    /// created per row, and a direct column-name===member-name mapping is assumed (case insensitive).
    /// </returns>
    public static T QuerySingle<T>(this IDbConnection cnn, CommandDefinition command) =>
        QueryRowImpl<T>(cnn, Row.Single, ref command, typeof(T));

    /// <summary>
    /// Executes a query, returning the data typed as <typeparamref name="T"/>.
    /// </summary>
    /// <typeparam name="T">The type of results to return.</typeparam>
    /// <param name="cnn">The connection to query on.</param>
    /// <param name="command">The command used to query on this connection.</param>
    /// <returns>
    /// A single instance of the supplied type; if a basic type (int, string, etc) is queried then the data from the first column is assumed, otherwise an instance is
    /// created per row, and a direct column-name===member-name mapping is assumed (case insensitive).
    /// </returns>
    public static T QuerySingleOrDefault<T>(this IDbConnection cnn, CommandDefinition command) =>
        QueryRowImpl<T>(cnn, Row.SingleOrDefault, ref command, typeof(T));

    /// <summary>
    /// Execute a command that returns multiple result sets, and access each in turn.
    /// </summary>
    /// <param name="cnn">The connection to query on.</param>
    /// <param name="sql">The SQL to execute for this query.</param>
    /// <param name="param">The parameters to use for this query.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    public static SqlMapper.GridReader QueryMultiple(this IDbConnection cnn, string sql, object param = null,
        IDbTransaction transaction = null, int? commandTimeout = null, CommandType? commandType = null)
    {
        var command =
            new CommandDefinition(sql, param, transaction, commandTimeout, commandType, CommandFlags.Buffered);
        return QueryMultipleImpl(cnn, ref command);
    }

    /// <summary>
    /// Execute a command that returns multiple result sets, and access each in turn.
    /// </summary>
    /// <param name="cnn">The connection to query on.</param>
    /// <param name="command">The command to execute for this query.</param>
    public static SqlMapper.GridReader QueryMultiple(this IDbConnection cnn, CommandDefinition command) =>
        QueryMultipleImpl(cnn, ref command);

    private static SqlMapper.GridReader QueryMultipleImpl(this IDbConnection cnn, ref CommandDefinition command)
    {
        object param = command.Parameters;
        var identity = new SqlMapper.Identity(command.CommandText, command.CommandType, cnn,
            typeof(SqlMapper.GridReader), param?.GetType());
        CacheInfo info = GetCacheInfo(identity, param, command.AddToCache);

        IDbCommand cmd = null;
        IDataReader reader = null;
        bool wasClosed = cnn.State == ConnectionState.Closed;
        try
        {
            if (wasClosed) cnn.Open();
            cmd = command.SetupCommand(cnn, info.ParamReader);
            reader = ExecuteReaderWithFlagsFallback(cmd, wasClosed, CommandBehavior.SequentialAccess);

            var result = new SqlMapper.GridReader(cmd, reader, identity, command.Parameters as DynamicParameters,
                command.AddToCache);
            cmd = null; // now owned by result
            wasClosed = false; // *if* the connection was closed and we got this far, then we now have a reader
            // with the CloseConnection flag, so the reader will deal with the connection; we
            // still need something in the "finally" to ensure that broken SQL still results
            // in the connection closing itself
            return result;
        }
        catch
        {
            if (reader != null)
            {
                if (!reader.IsClosed)
                {
                    try { cmd?.Cancel(); }
                    catch
                    {
                        /* don't spoil the existing exception */
                    }
                }

                reader.Dispose();
            }

            cmd?.Parameters.Clear();
            cmd?.Dispose();
            if (wasClosed) cnn.Close();
            throw;
        }
    }

    private static IDataReader ExecuteReaderWithFlagsFallback(IDbCommand cmd, bool wasClosed, CommandBehavior behavior)
    {
        try
        {
            return cmd.ExecuteReader(GetBehavior(wasClosed, behavior));
        }
        catch (ArgumentException ex)
        {
            // thanks, Sqlite!
            if (SqlMapper.Settings.DisableCommandBehaviorOptimizations(behavior, ex))
            {
                // we can retry; this time it will have different flags
                return cmd.ExecuteReader(GetBehavior(wasClosed, behavior));
            }

            throw;
        }
    }

    private static IEnumerable<T> QueryImpl<T>(this IDbConnection cnn, CommandDefinition command, Type effectiveType)
    {
        object param = command.Parameters;
        var identity = new SqlMapper.Identity(command.CommandText, command.CommandType, cnn, effectiveType,
            param?.GetType());
        var info = GetCacheInfo(identity, param, command.AddToCache);

        IDbCommand cmd = null;
        IDataReader reader = null;

        bool wasClosed = cnn.State == ConnectionState.Closed;
        try
        {
            cmd = command.SetupCommand(cnn, info.ParamReader);

            if (wasClosed) cnn.Open();
            reader = ExecuteReaderWithFlagsFallback(cmd, wasClosed,
                CommandBehavior.SequentialAccess | CommandBehavior.SingleResult);
            wasClosed = false; // *if* the connection was closed and we got this far, then we now have a reader
            // with the CloseConnection flag, so the reader will deal with the connection; we
            // still need something in the "finally" to ensure that broken SQL still results
            // in the connection closing itself
            var tuple = info.Deserializer;
            int hash = GetColumnHash(reader);
            if (tuple.Func == null || tuple.Hash != hash)
            {
                if (reader.FieldCount == 0) //https://code.google.com/p/dapper-dot-net/issues/detail?id=57
                    yield break;
                tuple = info.Deserializer =
                    new DeserializerState(hash, GetDeserializer(effectiveType, reader, 0, -1, false));
                if (command.AddToCache) SetQueryCache(identity, info);
            }

            var func = tuple.Func;
            var convertToType = Nullable.GetUnderlyingType(effectiveType) ?? effectiveType;
            while (reader.Read())
            {
                object val = func(reader);
                yield return GetValue<T>(reader, effectiveType, val);
            }

            while (reader.NextResult())
            {
                /* ignore subsequent result sets */
            }

            // happy path; close the reader cleanly - no
            // need for "Cancel" etc
            reader.Dispose();
            reader = null;

            command.OnCompleted();
        }
        finally
        {
            if (reader != null)
            {
                if (!reader.IsClosed)
                {
                    try { cmd.Cancel(); }
                    catch
                    {
                        /* don't spoil the existing exception */
                    }
                }

                reader.Dispose();
            }

            if (wasClosed) cnn.Close();

            cmd?.Parameters.Clear();
            cmd?.Dispose();
        }
    }

    [Flags]
    internal enum Row
    {
        First = 0,
        FirstOrDefault = 1, //  & FirstOrDefault != 0: allow zero rows
        Single = 2, // & Single != 0: demand at least one row
        SingleOrDefault = 3
    }

    private static readonly int[] ErrTwoRows = new int[2], ErrZeroRows = Array.Empty<int>();

    private static void ThrowMultipleRows(Row row)
    {
        _ = row switch
        {
            Row.Single => ErrTwoRows.Single(),
            Row.SingleOrDefault => ErrTwoRows.SingleOrDefault(),
            _ => throw new InvalidOperationException(),
        };
    }

    private static void ThrowZeroRows(Row row)
    {
        _ = row switch
        {
            // get the standard exception from the runtime
            Row.First => ErrZeroRows.First(),
            Row.Single => ErrZeroRows.Single(),
            _ => throw new InvalidOperationException(),
        };
    }

    private static T QueryRowImpl<T>(IDbConnection cnn, Row row, ref CommandDefinition command, Type effectiveType)
    {
        object param = command.Parameters;
        var identity = new SqlMapper.Identity(command.CommandText, command.CommandType, cnn, effectiveType,
            param?.GetType());
        var info = GetCacheInfo(identity, param, command.AddToCache);

        IDbCommand cmd = null;
        IDataReader reader = null;

        bool wasClosed = cnn.State == ConnectionState.Closed;
        try
        {
            cmd = command.SetupCommand(cnn, info.ParamReader);

            if (wasClosed) cnn.Open();
            reader = ExecuteReaderWithFlagsFallback(cmd, wasClosed, (row & Row.Single) != 0
                ? CommandBehavior.SequentialAccess |
                  CommandBehavior.SingleResult // need to allow multiple rows, to check fail condition
                : CommandBehavior.SequentialAccess | CommandBehavior.SingleResult | CommandBehavior.SingleRow);
            wasClosed = false; // *if* the connection was closed and we got this far, then we now have a reader

            T result = default;
            if (reader.Read() && reader.FieldCount != 0)
            {
                // with the CloseConnection flag, so the reader will deal with the connection; we
                // still need something in the "finally" to ensure that broken SQL still results
                // in the connection closing itself
                result = ReadRow<T>(info, identity, ref command, effectiveType, reader);

                if ((row & Row.Single) != 0 && reader.Read()) ThrowMultipleRows(row);
                while (reader.Read())
                {
                    /* ignore subsequent rows */
                }
            }
            else if ((row & Row.FirstOrDefault) == 0) // demanding a row, and don't have one
            {
                ThrowZeroRows(row);
            }

            while (reader.NextResult())
            {
                /* ignore subsequent result sets */
            }

            // happy path; close the reader cleanly - no
            // need for "Cancel" etc
            reader.Dispose();
            reader = null;

            command.OnCompleted();
            return result;
        }
        finally
        {
            if (reader != null)
            {
                if (!reader.IsClosed)
                {
                    try { cmd.Cancel(); }
                    catch
                    {
                        /* don't spoil the existing exception */
                    }
                }

                reader.Dispose();
            }

            if (wasClosed) cnn.Close();
            cmd?.Parameters.Clear();
            cmd?.Dispose();
        }
    }

    /// <summary>
    /// Shared value deserialization path for QueryRowImpl and QueryRowAsync
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static T ReadRow<T>(CacheInfo info, SqlMapper.Identity identity, ref CommandDefinition command,
        Type effectiveType, IDataReader reader)
    {
        var tuple = info.Deserializer;
        int hash = GetColumnHash(reader);
        if (tuple.Func == null || tuple.Hash != hash)
        {
            tuple = info.Deserializer =
                new DeserializerState(hash, GetDeserializer(effectiveType, reader, 0, -1, false));
            if (command.AddToCache) SetQueryCache(identity, info);
        }

        var func = tuple.Func;
        object val = func(reader);
        return GetValue<T>(reader, effectiveType, val);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static T GetValue<T>(IDataReader reader, Type effectiveType, object val)
    {
        if (val is T tVal)
        {
            return tVal;
        }
        else if (val == null && (!effectiveType.IsValueType || Nullable.GetUnderlyingType(effectiveType) != null))
        {
            return default;
        }
        else if (val is Array array && typeof(T).IsArray)
        {
            var elementType = typeof(T).GetElementType();
            var result = Array.CreateInstance(elementType, array.Length);
            for (int i = 0; i < array.Length; i++)
                result.SetValue(Convert.ChangeType(array.GetValue(i), elementType, CultureInfo.InvariantCulture), i);
            return (T)(object)result;
        }
        else
        {
            try
            {
                var convertToType = Nullable.GetUnderlyingType(effectiveType) ?? effectiveType;
                return (T)Convert.ChangeType(val, convertToType, CultureInfo.InvariantCulture);
            }
            catch (Exception ex)
            {
#pragma warning disable CS0618 // Type or member is obsolete
                ThrowDataException(ex, 0, reader, val);
#pragma warning restore CS0618 // Type or member is obsolete
                return default; // For the compiler - we've already thrown
            }
        }
    }

    /// <summary>
    /// Perform a multi-mapping query with 2 input types.
    /// This returns a single type, combined from the raw types via <paramref name="map"/>.
    /// </summary>
    /// <typeparam name="TFirst">The first type in the recordset.</typeparam>
    /// <typeparam name="TSecond">The second type in the recordset.</typeparam>
    /// <typeparam name="TReturn">The combined type to return.</typeparam>
    /// <param name="cnn">The connection to query on.</param>
    /// <param name="sql">The SQL to execute for this query.</param>
    /// <param name="map">The function to map row types to the return type.</param>
    /// <param name="param">The parameters to use for this query.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="buffered">Whether to buffer the results in memory.</param>
    /// <param name="splitOn">The field we should split and read the second object from (default: "Id").</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>An enumerable of <typeparamref name="TReturn"/>.</returns>
    public static IEnumerable<TReturn> Query<TFirst, TSecond, TReturn>(this IDbConnection cnn, string sql,
        Func<TFirst, TSecond, TReturn> map, object param = null, IDbTransaction transaction = null,
        bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null) =>
        MultiMap<TFirst, TSecond, DontMap, DontMap, DontMap, DontMap, DontMap, TReturn>(cnn, sql, map, param,
            transaction, buffered, splitOn, commandTimeout, commandType);

    /// <summary>
    /// Perform a multi-mapping query with 3 input types.
    /// This returns a single type, combined from the raw types via <paramref name="map"/>.
    /// </summary>
    /// <typeparam name="TFirst">The first type in the recordset.</typeparam>
    /// <typeparam name="TSecond">The second type in the recordset.</typeparam>
    /// <typeparam name="TThird">The third type in the recordset.</typeparam>
    /// <typeparam name="TReturn">The combined type to return.</typeparam>
    /// <param name="cnn">The connection to query on.</param>
    /// <param name="sql">The SQL to execute for this query.</param>
    /// <param name="map">The function to map row types to the return type.</param>
    /// <param name="param">The parameters to use for this query.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="buffered">Whether to buffer the results in memory.</param>
    /// <param name="splitOn">The field we should split and read the second object from (default: "Id").</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>An enumerable of <typeparamref name="TReturn"/>.</returns>
    public static IEnumerable<TReturn> Query<TFirst, TSecond, TThird, TReturn>(this IDbConnection cnn, string sql,
        Func<TFirst, TSecond, TThird, TReturn> map, object param = null, IDbTransaction transaction = null,
        bool buffered = true, string splitOn = "Id", int? commandTimeout = null, CommandType? commandType = null) =>
        MultiMap<TFirst, TSecond, TThird, DontMap, DontMap, DontMap, DontMap, TReturn>(cnn, sql, map, param,
            transaction, buffered, splitOn, commandTimeout, commandType);

    /// <summary>
    /// Perform a multi-mapping query with 4 input types.
    /// This returns a single type, combined from the raw types via <paramref name="map"/>.
    /// </summary>
    /// <typeparam name="TFirst">The first type in the recordset.</typeparam>
    /// <typeparam name="TSecond">The second type in the recordset.</typeparam>
    /// <typeparam name="TThird">The third type in the recordset.</typeparam>
    /// <typeparam name="TFourth">The fourth type in the recordset.</typeparam>
    /// <typeparam name="TReturn">The combined type to return.</typeparam>
    /// <param name="cnn">The connection to query on.</param>
    /// <param name="sql">The SQL to execute for this query.</param>
    /// <param name="map">The function to map row types to the return type.</param>
    /// <param name="param">The parameters to use for this query.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="buffered">Whether to buffer the results in memory.</param>
    /// <param name="splitOn">The field we should split and read the second object from (default: "Id").</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>An enumerable of <typeparamref name="TReturn"/>.</returns>
    public static IEnumerable<TReturn> Query<TFirst, TSecond, TThird, TFourth, TReturn>(this IDbConnection cnn,
        string sql, Func<TFirst, TSecond, TThird, TFourth, TReturn> map, object param = null,
        IDbTransaction transaction = null, bool buffered = true, string splitOn = "Id", int? commandTimeout = null,
        CommandType? commandType = null) =>
        MultiMap<TFirst, TSecond, TThird, TFourth, DontMap, DontMap, DontMap, TReturn>(cnn, sql, map, param,
            transaction, buffered, splitOn, commandTimeout, commandType);

    /// <summary>
    /// Perform a multi-mapping query with 5 input types.
    /// This returns a single type, combined from the raw types via <paramref name="map"/>.
    /// </summary>
    /// <typeparam name="TFirst">The first type in the recordset.</typeparam>
    /// <typeparam name="TSecond">The second type in the recordset.</typeparam>
    /// <typeparam name="TThird">The third type in the recordset.</typeparam>
    /// <typeparam name="TFourth">The fourth type in the recordset.</typeparam>
    /// <typeparam name="TFifth">The fifth type in the recordset.</typeparam>
    /// <typeparam name="TReturn">The combined type to return.</typeparam>
    /// <param name="cnn">The connection to query on.</param>
    /// <param name="sql">The SQL to execute for this query.</param>
    /// <param name="map">The function to map row types to the return type.</param>
    /// <param name="param">The parameters to use for this query.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="buffered">Whether to buffer the results in memory.</param>
    /// <param name="splitOn">The field we should split and read the second object from (default: "Id").</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <returns>An enumerable of <typeparamref name="TReturn"/>.</returns>
    public static IEnumerable<TReturn> RetryQuery<TFirst, TSecond, TThird, TFourth, TFifth, TReturn>(this IDbConnection cnn,
        string sql,
        Func<TFirst, TSecond, TThird, TFourth, TFifth, TReturn> map,
        object? param = null,
        IDbTransaction? transaction = null,
        bool buffered = true,
        string splitOn = "Id",
        int? commandTimeout = null,
        CommandType? commandType = null,
        ResiliencePipeline? retryPolicy = null)
    {
        retryPolicy ??= SqlRetryPolicy.Default;
        return retryPolicy.Execute(() =>
            cnn.Query(sql, map, param, transaction, buffered, splitOn, commandTimeout, commandType));
    }

    /// <summary>
    /// Perform a multi-mapping query with 6 input types.
    /// This returns a single type, combined from the raw types via <paramref name="map"/>.
    /// </summary>
    /// <typeparam name="TFirst">The first type in the recordset.</typeparam>
    /// <typeparam name="TSecond">The second type in the recordset.</typeparam>
    /// <typeparam name="TThird">The third type in the recordset.</typeparam>
    /// <typeparam name="TFourth">The fourth type in the recordset.</typeparam>
    /// <typeparam name="TFifth">The fifth type in the recordset.</typeparam>
    /// <typeparam name="TSixth">The sixth type in the recordset.</typeparam>
    /// <typeparam name="TReturn">The combined type to return.</typeparam>
    /// <param name="cnn">The connection to query on.</param>
    /// <param name="sql">The SQL to execute for this query.</param>
    /// <param name="map">The function to map row types to the return type.</param>
    /// <param name="param">The parameters to use for this query.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="buffered">Whether to buffer the results in memory.</param>
    /// <param name="splitOn">The field we should split and read the second object from (default: "Id").</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <param name="retryPolicy">The retry policy.</param>
    /// <returns>An enumerable of <typeparamref name="TReturn"/>.</returns>
    public static IEnumerable<TReturn> RetryQuery<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TReturn>(
        this IDbConnection cnn,
        string sql,
        Func<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TReturn> map,
        object? param = null,
        IDbTransaction? transaction = null,
        bool buffered = true,
        string splitOn = "Id",
        int? commandTimeout = null,
        CommandType? commandType = null,
        ResiliencePipeline? retryPolicy = null)
    {
        retryPolicy ??= SqlRetryPolicy.Default;
        return retryPolicy.Execute(() =>
            cnn.Query(sql, map, param, transaction, buffered, splitOn, commandTimeout, commandType));
    }

/// <summary>
    /// Perform a multi-mapping query with 7 input types. If you need more types -> use Query with Type[] parameter.
    /// This returns a single type, combined from the raw types via <paramref name="map"/>.
    /// </summary>
    /// <typeparam name="TFirst">The first type in the recordset.</typeparam>
    /// <typeparam name="TSecond">The second type in the recordset.</typeparam>
    /// <typeparam name="TThird">The third type in the recordset.</typeparam>
    /// <typeparam name="TFourth">The fourth type in the recordset.</typeparam>
    /// <typeparam name="TFifth">The fifth type in the recordset.</typeparam>
    /// <typeparam name="TSixth">The sixth type in the recordset.</typeparam>
    /// <typeparam name="TSeventh">The seventh type in the recordset.</typeparam>
    /// <typeparam name="TReturn">The combined type to return.</typeparam>
    /// <param name="cnn">The connection to query on.</param>
    /// <param name="sql">The SQL to execute for this query.</param>
    /// <param name="map">The function to map row types to the return type.</param>
    /// <param name="param">The parameters to use for this query.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="buffered">Whether to buffer the results in memory.</param>
    /// <param name="splitOn">The field we should split and read the second object from (default: "Id").</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch.</param>
    /// <param name="retryPolicy">the retry policy.</param>
    /// <returns>An enumerable of <typeparamref name="TReturn"/>.</returns>
    public static IEnumerable<TReturn> RetryQuery<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TSeventh, TReturn>(
        this IDbConnection cnn,
        string sql,
        Func<TFirst, TSecond, TThird, TFourth, TFifth, TSixth, TSeventh, TReturn> map,
        object? param = null,
        IDbTransaction? transaction = null,
        bool buffered = true,
        string splitOn = "Id",
        int? commandTimeout = null,
        CommandType? commandType = null,
        ResiliencePipeline? retryPolicy = null)
    {
        retryPolicy ??= SqlRetryPolicy.Default;
        return retryPolicy.Execute(() =>
            cnn.Query(sql, map, param, transaction, buffered, splitOn, commandTimeout, commandType));
    }

    /// <summary>
    /// Perform a multi-mapping query with an arbitrary number of input types.
    /// This returns a single type, combined from the raw types via <paramref name="map"/>.
    /// </summary>
    /// <typeparam name="TReturn">The combined type to return.</typeparam>
    /// <param name="cnn">The connection to query on.</param>
    /// <param name="sql">The SQL to execute for this query.</param>
    /// <param name="types">Array of types in the recordset.</param>
    /// <param name="map">The function to map row types to the return type.</param>
    /// <param name="param">The parameters to use for this query.</param>
    /// <param name="transaction">The transaction to use for this query.</param>
    /// <param name="buffered">Whether to buffer the results in memory.</param>
    /// <param name="splitOn">The field we should split and read the second object from (default: "Id").</param>
    /// <param name="commandTimeout">Number of seconds before command execution timeout.</param>
    /// <param name="commandType">Is it a stored proc or a batch?</param>
    /// <param name="retryPolicy">The retry policy.</param>
    /// <returns>An enumerable of <typeparamref name="TReturn"/>.</returns>
    public static IEnumerable<TReturn> RetryQuery<TReturn>(
        this IDbConnection cnn,
        string sql,
        Type[] types,
        Func<object[], TReturn> map,
        object? param = null,
        IDbTransaction? transaction = null,
        bool buffered = true,
        string splitOn = "Id",
        int? commandTimeout = null,
        CommandType? commandType = null,
        ResiliencePipeline? retryPolicy = null)
    {
        retryPolicy ??= SqlRetryPolicy.Default;
        return retryPolicy.Execute(() =>
            cnn.Query<TReturn>(sql, types, map, param, transaction, buffered, splitOn, commandTimeout, commandType));
    }
}